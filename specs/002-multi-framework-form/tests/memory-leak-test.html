<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Leak Detection Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
        .test-result { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .pass { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .fail { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .warning { background-color: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        button { padding: 8px 16px; margin: 5px; cursor: pointer; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; }
        .memory-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }
        .memory-card { padding: 10px; border: 1px solid #ccc; border-radius: 4px; background: #f9f9f9; }
        .leak-scenario { margin: 10px 0; padding: 10px; border: 1px solid #ffcccc; border-radius: 4px; background: #fff8f8; }
        .chart { width: 100%; height: 200px; border: 1px solid #ddd; margin: 10px 0; position: relative; background: #f8f9fa; }
    </style>
</head>
<body>
    <h1>Memory Leak Detection Test</h1>
    <p><strong>Purpose:</strong> Detect and validate memory leaks in form tracking operations, particularly MutationObserver and event listener cleanup</p>

    <div class="test-section">
        <h2>Test Control</h2>
        <button onclick="startMemoryTest()">Start Memory Leak Test</button>
        <button onclick="runAllLeakScenarios()">Run All Leak Scenarios</button>
        <button onclick="forceGarbageCollection()">Force Garbage Collection</button>
        <button onclick="clearResults()">Clear Results</button>
        <button onclick="exportMemoryReport()">Export Memory Report</button>
    </div>

    <div class="test-section">
        <h2>Current Memory Statistics</h2>
        <div class="memory-stats" id="memoryStats"></div>
        <div class="chart" id="memoryChart"></div>
    </div>

    <div class="test-section">
        <h2>Test Results</h2>
        <div id="testResults"></div>
    </div>

    <div class="test-section">
        <h2>Memory Leak Test Scenarios</h2>

        <div class="leak-scenario">
            <h4>üîç Observer Memory Leaks</h4>
            <button onclick="testMutationObserverLeak()">MutationObserver Leak Test</button>
            <button onclick="testPerformanceObserverLeak()">PerformanceObserver Leak Test</button>
            <button onclick="testNestedObserverLeak()">Nested Observer Leak Test</button>
            <button onclick="testObserverCleanupFailure()">Observer Cleanup Failure Test</button>
        </div>

        <div class="leak-scenario">
            <h4>üì° Event Listener Memory Leaks</h4>
            <button onclick="testEventListenerLeak()">Event Listener Leak Test</button>
            <button onclick="testFormEventLeak()">Form Event Listener Leak Test</button>
            <button onclick="testGlobalEventLeak()">Global Event Listener Leak Test</button>
            <button onclick="testEventBubblingLeak()">Event Bubbling Leak Test</button>
        </div>

        <div class="leak-scenario">
            <h4>üíæ Data Storage Memory Leaks</h4>
            <button onclick="testFormDataCacheLeak()">Form Data Cache Leak Test</button>
            <button onclick="testSessionStorageLeak()">SessionStorage Reference Leak Test</button>
            <button onclick="testRetryLogicLeak()">Retry Logic State Leak Test</button>
            <button onclick="testPerformanceMetricsLeak()">Performance Metrics Leak Test</button>
        </div>

        <div class="leak-scenario">
            <h4>üéØ Framework-Specific Leaks</h4>
            <button onclick="testElementorFormLeak()">Elementor Form Leak Test</button>
            <button onclick="testMultiFrameworkLeak()">Multi-Framework Leak Test</button>
            <button onclick="testDynamicFormLeak()">Dynamic Form Loading Leak Test</button>
            <button onclick="testModalFormLeak()">Modal Form Leak Test</button>
        </div>
    </div>

    <div class="test-section">
        <h2>Memory Leak Detection Criteria</h2>
        <h3>‚úÖ Expected Behavior (No Leaks):</h3>
        <ul>
            <li><strong>Observer Cleanup:</strong> All MutationObservers disconnected within timeout periods</li>
            <li><strong>Event Listener Cleanup:</strong> All event listeners removed when forms are destroyed</li>
            <li><strong>Memory Growth:</strong> Memory usage remains stable over multiple form submissions</li>
            <li><strong>Reference Cleanup:</strong> No lingering references to DOM elements or large objects</li>
            <li><strong>Cache Limits:</strong> Data caches respect size limits and expire appropriately</li>
        </ul>
        <h3>‚ùå Memory Leak Indicators:</h3>
        <ul>
            <li>Growing number of active MutationObservers</li>
            <li>Increasing event listener counts</li>
            <li>Steadily increasing memory usage over time</li>
            <li>Retained DOM elements after form removal</li>
            <li>Growing cache sizes without cleanup</li>
        </ul>
    </div>

    <!-- Mock Forms for Testing -->
    <div style="display: none;" id="leak-test-forms">
        <!-- Forms will be dynamically created and destroyed for leak testing -->
    </div>

    <script>
        // Memory leak detection system
        var memoryLeakDetector = {
            baseline: {},
            measurements: [],
            observers: {
                active: new Set(),
                created: 0,
                cleaned: 0
            },
            eventListeners: {
                active: new Map(),
                added: 0,
                removed: 0
            },
            caches: {
                sizes: new Map(),
                maxSizes: new Map()
            },
            testResults: [],
            isRunning: false,
            intervalId: null
        };

        // Memory measurement utilities
        function measureMemoryUsage() {
            var measurement = {
                timestamp: Date.now(),
                heap: null,
                observers: memoryLeakDetector.observers.active.size,
                listeners: getTotalEventListeners(),
                caches: getTotalCacheSize(),
                performance: getPerformanceMemory()
            };

            if (window.performance && window.performance.memory) {
                measurement.heap = {
                    used: window.performance.memory.usedJSHeapSize,
                    total: window.performance.memory.totalJSHeapSize,
                    limit: window.performance.memory.jsHeapSizeLimit
                };
            }

            return measurement;
        }

        function getTotalEventListeners() {
            var total = 0;
            memoryLeakDetector.eventListeners.active.forEach(function(count) {
                total += count;
            });
            return total;
        }

        function getTotalCacheSize() {
            var total = 0;
            memoryLeakDetector.caches.sizes.forEach(function(size) {
                total += size;
            });
            return total;
        }

        function getPerformanceMemory() {
            if (window.cuftPerformanceMonitor) {
                try {
                    var report = window.cuftPerformanceMonitor.getPerformanceReport();
                    return {
                        samples: report.totalProcessed || 0,
                        observers: report.observers ? report.observers.active : 0
                    };
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        function recordMemoryMeasurement() {
            var measurement = measureMemoryUsage();
            memoryLeakDetector.measurements.push(measurement);

            // Keep only recent measurements
            if (memoryLeakDetector.measurements.length > 100) {
                memoryLeakDetector.measurements.shift();
            }

            updateMemoryDisplay(measurement);
            return measurement;
        }

        function updateMemoryDisplay(measurement) {
            var statsDiv = document.getElementById('memoryStats');
            var html = '';

            if (measurement.heap) {
                html += '<div class="memory-card"><h4>JavaScript Heap</h4>';
                html += '<div>Used: ' + formatBytes(measurement.heap.used) + '</div>';
                html += '<div>Total: ' + formatBytes(measurement.heap.total) + '</div>';
                html += '<div>Limit: ' + formatBytes(measurement.heap.limit) + '</div>';
                html += '</div>';
            }

            html += '<div class="memory-card"><h4>Observers</h4>';
            html += '<div>Active: ' + measurement.observers + '</div>';
            html += '<div>Created: ' + memoryLeakDetector.observers.created + '</div>';
            html += '<div>Cleaned: ' + memoryLeakDetector.observers.cleaned + '</div>';
            html += '</div>';

            html += '<div class="memory-card"><h4>Event Listeners</h4>';
            html += '<div>Active: ' + measurement.listeners + '</div>';
            html += '<div>Added: ' + memoryLeakDetector.eventListeners.added + '</div>';
            html += '<div>Removed: ' + memoryLeakDetector.eventListeners.removed + '</div>';
            html += '</div>';

            html += '<div class="memory-card"><h4>Caches</h4>';
            html += '<div>Total Size: ' + measurement.caches + ' items</div>';
            html += '<div>Cache Count: ' + memoryLeakDetector.caches.sizes.size + '</div>';
            html += '</div>';

            if (measurement.performance) {
                html += '<div class="memory-card"><h4>Performance Monitor</h4>';
                html += '<div>Samples: ' + measurement.performance.samples + '</div>';
                html += '<div>Observers: ' + measurement.performance.observers + '</div>';
                html += '</div>';
            }

            statsDiv.innerHTML = html;
        }

        function formatBytes(bytes) {
            if (!bytes) return '0 B';
            var k = 1024;
            var sizes = ['B', 'KB', 'MB', 'GB'];
            var i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Observer tracking system
        function patchMutationObserver() {
            var OriginalObserver = window.MutationObserver;
            var observerMap = new WeakMap();

            window.MutationObserver = function(callback) {
                var observer = new OriginalObserver(callback);
                var observerId = 'obs-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                memoryLeakDetector.observers.active.add(observerId);
                memoryLeakDetector.observers.created++;
                observerMap.set(observer, observerId);

                var originalDisconnect = observer.disconnect;
                observer.disconnect = function() {
                    var id = observerMap.get(observer);
                    if (id && memoryLeakDetector.observers.active.has(id)) {
                        memoryLeakDetector.observers.active.delete(id);
                        memoryLeakDetector.observers.cleaned++;
                    }
                    return originalDisconnect.call(observer);
                };

                return observer;
            };

            // Copy static methods
            Object.getOwnPropertyNames(OriginalObserver).forEach(function(name) {
                if (typeof OriginalObserver[name] === 'function') {
                    window.MutationObserver[name] = OriginalObserver[name];
                }
            });
        }

        // Event listener tracking system
        function patchEventListeners() {
            var originalAdd = EventTarget.prototype.addEventListener;
            var originalRemove = EventTarget.prototype.removeEventListener;
            var listenerMap = new WeakMap();

            EventTarget.prototype.addEventListener = function(type, listener, options) {
                var elementListeners = listenerMap.get(this) || new Map();
                var typeListeners = elementListeners.get(type) || new Set();

                typeListeners.add(listener);
                elementListeners.set(type, typeListeners);
                listenerMap.set(this, elementListeners);

                var currentCount = memoryLeakDetector.eventListeners.active.get(type) || 0;
                memoryLeakDetector.eventListeners.active.set(type, currentCount + 1);
                memoryLeakDetector.eventListeners.added++;

                return originalAdd.call(this, type, listener, options);
            };

            EventTarget.prototype.removeEventListener = function(type, listener, options) {
                var elementListeners = listenerMap.get(this);
                if (elementListeners) {
                    var typeListeners = elementListeners.get(type);
                    if (typeListeners && typeListeners.has(listener)) {
                        typeListeners.delete(listener);
                        if (typeListeners.size === 0) {
                            elementListeners.delete(type);
                        }

                        var currentCount = memoryLeakDetector.eventListeners.active.get(type) || 0;
                        memoryLeakDetector.eventListeners.active.set(type, Math.max(0, currentCount - 1));
                        memoryLeakDetector.eventListeners.removed++;
                    }
                }

                return originalRemove.call(this, type, listener, options);
            };
        }

        // Memory leak test scenarios
        function testMutationObserverLeak() {
            runMemoryLeakTest('MutationObserver Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Create multiple observers without proper cleanup
                for (var i = 0; i < 10; i++) {
                    var div = document.createElement('div');
                    div.id = 'leak-test-' + i;
                    container.appendChild(div);

                    var observer = new MutationObserver(function() {
                        // Observer callback with potential memory reference
                        console.log('Observer triggered');
                    });
                    observer.observe(div, { childList: true, subtree: true });

                    // Simulate observer not being cleaned up (memory leak scenario)
                    // In a proper implementation, observer.disconnect() would be called
                }

                // Remove elements but leave observers running
                setTimeout(function() {
                    container.innerHTML = '';
                }, 1000);
            });
        }

        function testPerformanceObserverLeak() {
            runMemoryLeakTest('PerformanceObserver Leak Test', function() {
                if (window.PerformanceObserver) {
                    // Create multiple performance observers
                    for (var i = 0; i < 5; i++) {
                        try {
                            var perfObserver = new PerformanceObserver(function(list) {
                                var entries = list.getEntries();
                                // Process entries without cleanup
                            });
                            perfObserver.observe({ entryTypes: ['measure', 'navigation'] });

                            // Simulate observer not being disconnected
                        } catch (e) {
                            // PerformanceObserver may not be supported
                        }
                    }
                }
            });
        }

        function testNestedObserverLeak() {
            runMemoryLeakTest('Nested Observer Leak Test', function() {
                var container = document.getElementById('leak-test-forms');
                var parentDiv = document.createElement('div');
                container.appendChild(parentDiv);

                // Create nested observers
                for (var i = 0; i < 5; i++) {
                    var childDiv = document.createElement('div');
                    parentDiv.appendChild(childDiv);

                    var parentObserver = new MutationObserver(function() {
                        // Create child observer in callback (potential leak)
                        var childObserver = new MutationObserver(function() {
                            console.log('Child observer');
                        });
                        childObserver.observe(childDiv, { attributes: true });
                    });
                    parentObserver.observe(parentDiv, { childList: true });

                    // Trigger parent observer
                    childDiv.setAttribute('data-test', 'trigger');
                }

                setTimeout(function() {
                    container.innerHTML = '';
                }, 1000);
            });
        }

        function testObserverCleanupFailure() {
            runMemoryLeakTest('Observer Cleanup Failure Test', function() {
                if (window.cuftObserverCleanup) {
                    // Test observer cleanup utility under stress
                    var container = document.getElementById('leak-test-forms');

                    for (var i = 0; i < 15; i++) {
                        var form = document.createElement('form');
                        form.className = 'elementor-form test-form-' + i;
                        container.appendChild(form);

                        // Create scoped observer (should be cleaned up automatically)
                        var scopedObserver = window.cuftObserverCleanup.createScopedObserver(
                            form,
                            function() { console.log('Scoped observer callback'); },
                            { timeout: 2000, context: 'Memory Leak Test' }
                        );

                        // Simulate form removal
                        setTimeout(function() {
                            if (form.parentNode) {
                                form.parentNode.removeChild(form);
                            }
                        }, 500 + i * 100);
                    }
                }
            });
        }

        function testEventListenerLeak() {
            runMemoryLeakTest('Event Listener Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Create forms with multiple event listeners
                for (var i = 0; i < 10; i++) {
                    var form = document.createElement('form');
                    form.id = 'listener-test-' + i;
                    container.appendChild(form);

                    // Add multiple event listeners without cleanup
                    var events = ['submit', 'click', 'change', 'input', 'focus'];
                    events.forEach(function(eventType) {
                        var listener = function(e) {
                            console.log('Event:', eventType, 'on form:', form.id);
                        };
                        form.addEventListener(eventType, listener);
                        // Simulate listener not being removed
                    });
                }

                // Remove forms but don't clean up listeners (memory leak)
                setTimeout(function() {
                    container.innerHTML = '';
                }, 1000);
            });
        }

        function testFormEventLeak() {
            runMemoryLeakTest('Form Event Listener Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Simulate framework-specific form events
                for (var i = 0; i < 8; i++) {
                    var form = document.createElement('form');
                    form.className = 'elementor-form cf7-form ninja-form';
                    container.appendChild(form);

                    // Add framework-specific listeners
                    var frameworkEvents = [
                        'submit_success',
                        'wpcf7mailsent',
                        'ninja_forms_submit_success'
                    ];

                    frameworkEvents.forEach(function(eventType) {
                        var listener = function(e) {
                            // Heavy processing in callback
                            var data = {
                                form: form,
                                timestamp: Date.now(),
                                eventType: eventType,
                                largeData: new Array(1000).fill('memory consuming data')
                            };
                            console.log('Framework event processed:', data);
                        };
                        form.addEventListener(eventType, listener);
                    });
                }

                setTimeout(function() {
                    container.innerHTML = '';
                }, 1000);
            });
        }

        function testGlobalEventLeak() {
            runMemoryLeakTest('Global Event Listener Leak Test', function() {
                // Add global event listeners that reference forms
                var forms = [];

                for (var i = 0; i < 5; i++) {
                    var form = document.createElement('form');
                    forms.push(form);

                    var globalListener = function(e) {
                        // Closure captures form reference
                        console.log('Global event referencing form:', form);
                    };

                    window.addEventListener('resize', globalListener);
                    window.addEventListener('scroll', globalListener);
                    document.addEventListener('click', globalListener);
                    // Global listeners not cleaned up when forms are removed
                }

                // Remove form references but leave global listeners
                forms = null;
            });
        }

        function testEventBubblingLeak() {
            runMemoryLeakTest('Event Bubbling Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Create nested form structure with bubbling events
                for (var i = 0; i < 5; i++) {
                    var wrapper = document.createElement('div');
                    var form = document.createElement('form');
                    var input = document.createElement('input');

                    wrapper.appendChild(form);
                    form.appendChild(input);
                    container.appendChild(wrapper);

                    // Add listeners at multiple levels
                    [wrapper, form, input].forEach(function(element, level) {
                        var listener = function(e) {
                            // Each listener creates references to all levels
                            var context = {
                                wrapper: wrapper,
                                form: form,
                                input: input,
                                level: level,
                                timestamp: Date.now()
                            };
                            console.log('Bubbling event:', context);
                        };

                        element.addEventListener('click', listener);
                        element.addEventListener('change', listener);
                    });
                }

                setTimeout(function() {
                    container.innerHTML = '';
                }, 1000);
            });
        }

        function testFormDataCacheLeak() {
            runMemoryLeakTest('Form Data Cache Leak Test', function() {
                // Simulate form data caching without proper cleanup
                var formDataCache = new Map();

                for (var i = 0; i < 20; i++) {
                    var formData = {
                        id: 'form-' + i,
                        timestamp: Date.now(),
                        fields: {},
                        largeObject: new Array(1000).fill({
                            key: 'value-' + Math.random(),
                            nested: {
                                data: new Array(100).fill('cached data')
                            }
                        })
                    };

                    // Add email and phone fields
                    for (var j = 0; j < 10; j++) {
                        formData.fields['field-' + j] = 'value-' + j + '-' + Math.random();
                    }

                    formDataCache.set('form-' + i, formData);
                }

                // Track cache size
                memoryLeakDetector.caches.sizes.set('formData', formDataCache.size);

                // Simulate cache not being cleaned up properly
                // In proper implementation, old entries would be removed
            });
        }

        function testSessionStorageLeak() {
            runMemoryLeakTest('SessionStorage Reference Leak Test', function() {
                // Create objects that hold references to sessionStorage data
                var storageReferences = [];

                for (var i = 0; i < 15; i++) {
                    var storageData = {
                        key: 'cuft-test-' + i,
                        data: {
                            form: 'form-' + i,
                            timestamp: Date.now(),
                            largeData: new Array(500).fill('session data')
                        }
                    };

                    try {
                        sessionStorage.setItem(storageData.key, JSON.stringify(storageData.data));
                        storageReferences.push(storageData); // Keeps reference in memory
                    } catch (e) {
                        // Storage quota may be exceeded
                    }
                }

                // Track storage references
                memoryLeakDetector.caches.sizes.set('sessionStorage', storageReferences.length);
            });
        }

        function testRetryLogicLeak() {
            runMemoryLeakTest('Retry Logic State Leak Test', function() {
                if (window.cuftRetryLogic) {
                    // Create multiple retry operations that accumulate state
                    for (var i = 0; i < 10; i++) {
                        var operationName = 'leak-test-operation-' + i;
                        var heavyData = new Array(200).fill('retry operation data');

                        window.cuftRetryLogic.executeWithRetry(operationName, function() {
                            // Operation that references heavy data
                            console.log('Retry operation with heavy data:', heavyData);

                            if (Math.random() < 0.7) {
                                throw new Error('Simulated retry failure');
                            }
                            return 'success';
                        }, {
                            maxAttempts: 3,
                            baseDelay: 100
                        });
                    }

                    // Check retry logic statistics
                    var stats = window.cuftRetryLogic.getRetryStats();
                    memoryLeakDetector.caches.sizes.set('retryLogic', stats.totalAttempts);
                }
            });
        }

        function testPerformanceMetricsLeak() {
            runMemoryLeakTest('Performance Metrics Leak Test', function() {
                if (window.cuftPerformanceMonitor) {
                    // Generate many performance measurements
                    for (var i = 0; i < 25; i++) {
                        var measurement = window.cuftPerformanceMonitor.startMeasurement(
                            'leak-test-' + i,
                            { heavy_context: new Array(100).fill('performance data') }
                        );

                        // Simulate some work
                        setTimeout(function() {
                            window.cuftPerformanceMonitor.endMeasurement(measurement);
                        }, Math.random() * 100);
                    }

                    // Create observers for leak testing
                    for (var j = 0; j < 10; j++) {
                        window.cuftPerformanceMonitor.trackObserverCreated(
                            'leak-observer-' + j,
                            document.body,
                            { context: 'leak test' }
                        );
                    }
                }
            });
        }

        function testElementorFormLeak() {
            runMemoryLeakTest('Elementor Form Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Create multiple Elementor forms
                for (var i = 0; i < 8; i++) {
                    var form = document.createElement('form');
                    form.className = 'elementor-form';
                    form.setAttribute('data-settings', JSON.stringify({ form_id: 'leak-test-' + i }));

                    // Add form fields
                    var emailInput = document.createElement('input');
                    emailInput.name = 'form_fields[email]';
                    emailInput.value = 'leak-test-' + i + '@example.com';

                    var phoneInput = document.createElement('input');
                    phoneInput.name = 'form_fields[phone]';
                    phoneInput.value = '555-000-' + i.toString().padStart(4, '0');

                    form.appendChild(emailInput);
                    form.appendChild(phoneInput);
                    container.appendChild(form);

                    // Trigger Elementor form events
                    var event = new CustomEvent('submit_success', {
                        bubbles: true,
                        detail: {
                            form: form,
                            settings: { form_id: 'leak-test-' + i }
                        }
                    });
                    form.dispatchEvent(event);
                }

                setTimeout(function() {
                    container.innerHTML = '';
                }, 1500);
            });
        }

        function testMultiFrameworkLeak() {
            runMemoryLeakTest('Multi-Framework Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Create forms for each framework
                var frameworks = [
                    { class: 'elementor-form', event: 'submit_success' },
                    { class: 'wpcf7-form', event: 'wpcf7mailsent' },
                    { class: 'ninja-forms-form', event: 'submit' },
                    { class: 'gform_wrapper', event: 'submit' },
                    { class: 'fusion-form', event: 'submit' }
                ];

                frameworks.forEach(function(framework, index) {
                    for (var i = 0; i < 3; i++) {
                        var form = document.createElement('form');
                        form.className = framework.class;
                        form.id = framework.class.replace('-', '_') + '_' + i;

                        var emailInput = document.createElement('input');
                        emailInput.type = 'email';
                        emailInput.name = 'email';
                        emailInput.value = 'multi-' + index + '-' + i + '@example.com';

                        form.appendChild(emailInput);
                        container.appendChild(form);

                        // Trigger framework-specific event
                        var event = new CustomEvent(framework.event, { bubbles: true });
                        form.dispatchEvent(event);
                    }
                });

                setTimeout(function() {
                    container.innerHTML = '';
                }, 2000);
            });
        }

        function testDynamicFormLeak() {
            runMemoryLeakTest('Dynamic Form Loading Leak Test', function() {
                var container = document.getElementById('leak-test-forms');

                // Simulate dynamic form loading/unloading
                for (var i = 0; i < 10; i++) {
                    (function(index) {
                        setTimeout(function() {
                            // Create form dynamically
                            var form = document.createElement('form');
                            form.className = 'dynamic-form-' + index;
                            form.innerHTML = '<input type="email" name="email" value="dynamic-' + index + '@example.com">';

                            container.appendChild(form);

                            // Add observers and listeners
                            var observer = new MutationObserver(function() {
                                console.log('Dynamic form observer');
                            });
                            observer.observe(form, { childList: true });

                            form.addEventListener('submit', function() {
                                console.log('Dynamic form submit');
                            });

                            // Remove form but potentially leave observers/listeners
                            setTimeout(function() {
                                if (form.parentNode) {
                                    form.parentNode.removeChild(form);
                                }
                                // Simulate observer not being disconnected (leak)
                            }, 1000);
                        }, index * 200);
                    })(i);
                }
            });
        }

        function testModalFormLeak() {
            runMemoryLeakTest('Modal Form Leak Test', function() {
                // Create modal forms that may not be properly cleaned up
                for (var i = 0; i < 5; i++) {
                    var modal = document.createElement('div');
                    modal.className = 'modal-' + i;
                    modal.style.display = 'none';

                    var form = document.createElement('form');
                    form.className = 'modal-form';

                    var input = document.createElement('input');
                    input.type = 'email';
                    input.value = 'modal-' + i + '@example.com';

                    form.appendChild(input);
                    modal.appendChild(form);
                    document.body.appendChild(modal);

                    // Add modal-specific event listeners
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                        }
                    });

                    // Show modal briefly
                    setTimeout(function() {
                        modal.style.display = 'block';
                    }, i * 100);

                    // Hide modal but potentially leave listeners
                    setTimeout(function() {
                        modal.style.display = 'none';
                        document.body.removeChild(modal);
                    }, 1000 + i * 100);
                }
            });
        }

        function runMemoryLeakTest(testName, testFunction) {
            addTestResult(testName, 'RUNNING', 'Starting memory leak test...');

            var beforeMeasurement = recordMemoryMeasurement();

            try {
                testFunction();

                // Wait for test to complete and measure again
                setTimeout(function() {
                    var afterMeasurement = recordMemoryMeasurement();
                    var leakAnalysis = analyzeMemoryLeak(beforeMeasurement, afterMeasurement);

                    var status = leakAnalysis.hasLeak ? 'FAIL' : 'PASS';
                    var message = leakAnalysis.summary;

                    addTestResult(testName, status, message, leakAnalysis);
                }, 3000);

            } catch (error) {
                addTestResult(testName, 'ERROR', 'Test execution failed: ' + error.message);
            }
        }

        function analyzeMemoryLeak(before, after) {
            var analysis = {
                hasLeak: false,
                summary: '',
                details: {},
                recommendations: []
            };

            // Analyze heap growth
            if (before.heap && after.heap) {
                var heapGrowth = after.heap.used - before.heap.used;
                var heapGrowthMB = heapGrowth / (1024 * 1024);
                analysis.details.heapGrowth = heapGrowthMB;

                if (heapGrowthMB > 5) {
                    analysis.hasLeak = true;
                    analysis.recommendations.push('Significant heap growth detected: ' + heapGrowthMB.toFixed(2) + ' MB');
                }
            }

            // Analyze observer growth
            var observerGrowth = after.observers - before.observers;
            analysis.details.observerGrowth = observerGrowth;

            if (observerGrowth > 5) {
                analysis.hasLeak = true;
                analysis.recommendations.push('Active observers increased by ' + observerGrowth);
            }

            // Analyze listener growth
            var listenerGrowth = after.listeners - before.listeners;
            analysis.details.listenerGrowth = listenerGrowth;

            if (listenerGrowth > 10) {
                analysis.hasLeak = true;
                analysis.recommendations.push('Event listeners increased by ' + listenerGrowth);
            }

            // Analyze cache growth
            var cacheGrowth = after.caches - before.caches;
            analysis.details.cacheGrowth = cacheGrowth;

            if (cacheGrowth > 20) {
                analysis.hasLeak = true;
                analysis.recommendations.push('Cache size increased by ' + cacheGrowth + ' items');
            }

            // Generate summary
            if (analysis.hasLeak) {
                analysis.summary = 'Memory leak detected - ' + analysis.recommendations.join(', ');
            } else {
                analysis.summary = 'No significant memory leaks detected';
                if (analysis.details.heapGrowth) {
                    analysis.summary += ' (heap: ' + analysis.details.heapGrowth.toFixed(2) + ' MB)';
                }
            }

            return analysis;
        }

        function runAllLeakScenarios() {
            clearResults();
            addTestResult('Memory Leak Test Suite', 'RUNNING', 'Starting comprehensive memory leak testing...');

            var tests = [
                testMutationObserverLeak,
                testPerformanceObserverLeak,
                testEventListenerLeak,
                testFormEventLeak,
                testFormDataCacheLeak,
                testElementorFormLeak,
                testMultiFrameworkLeak,
                testDynamicFormLeak
            ];

            tests.forEach(function(test, index) {
                setTimeout(test, index * 5000); // 5 second intervals
            });

            // Final analysis after all tests
            setTimeout(function() {
                var finalMeasurement = recordMemoryMeasurement();
                generateMemoryReport(finalMeasurement);
            }, tests.length * 5000 + 2000);
        }

        function startMemoryTest() {
            if (memoryLeakDetector.isRunning) {
                stopMemoryTest();
                return;
            }

            memoryLeakDetector.isRunning = true;
            memoryLeakDetector.baseline = recordMemoryMeasurement();

            // Start continuous monitoring
            memoryLeakDetector.intervalId = setInterval(function() {
                recordMemoryMeasurement();
            }, 5000);

            addTestResult('Memory Monitoring', 'RUNNING', 'Continuous memory monitoring started');
            document.querySelector('button[onclick="startMemoryTest()"]').textContent = 'Stop Memory Test';
        }

        function stopMemoryTest() {
            memoryLeakDetector.isRunning = false;

            if (memoryLeakDetector.intervalId) {
                clearInterval(memoryLeakDetector.intervalId);
                memoryLeakDetector.intervalId = null;
            }

            document.querySelector('button[onclick="startMemoryTest()"]').textContent = 'Start Memory Test';
            addTestResult('Memory Monitoring', 'STOPPED', 'Continuous memory monitoring stopped');
        }

        function forceGarbageCollection() {
            // Attempt garbage collection if available
            if (window.gc) {
                window.gc();
                addTestResult('Garbage Collection', 'SUCCESS', 'Manual garbage collection triggered');
            } else {
                // Simulate GC pressure
                var temp = [];
                for (var i = 0; i < 100000; i++) {
                    temp.push(new Array(100).fill(Math.random()));
                }
                temp = null;
                addTestResult('Garbage Collection', 'ATTEMPTED', 'GC pressure applied (window.gc not available)');
            }

            setTimeout(recordMemoryMeasurement, 1000);
        }

        function generateMemoryReport(finalMeasurement) {
            var report = {
                timestamp: new Date().toISOString(),
                baseline: memoryLeakDetector.baseline,
                final: finalMeasurement,
                totalTests: memoryLeakDetector.testResults.length,
                leaksDetected: memoryLeakDetector.testResults.filter(function(r) { return r.status === 'FAIL'; }).length,
                measurements: memoryLeakDetector.measurements.length,
                recommendations: []
            };

            if (report.leaksDetected > 0) {
                report.recommendations.push('Review failed tests for specific memory leak patterns');
                report.recommendations.push('Implement proper cleanup in observer and event listener management');
                report.recommendations.push('Add timeout-based cleanup for long-running operations');
            } else {
                report.recommendations.push('Memory management appears healthy');
                report.recommendations.push('Continue monitoring for long-term memory trends');
            }

            addTestResult('Memory Report', report.leaksDetected > 0 ? 'WARNING' : 'SUCCESS',
                'Test complete: ' + report.leaksDetected + '/' + report.totalTests + ' tests detected leaks',
                report);
        }

        function exportMemoryReport() {
            var report = {
                timestamp: new Date().toISOString(),
                measurements: memoryLeakDetector.measurements,
                testResults: memoryLeakDetector.testResults,
                observers: {
                    active: memoryLeakDetector.observers.active.size,
                    created: memoryLeakDetector.observers.created,
                    cleaned: memoryLeakDetector.observers.cleaned
                },
                eventListeners: {
                    active: getTotalEventListeners(),
                    added: memoryLeakDetector.eventListeners.added,
                    removed: memoryLeakDetector.eventListeners.removed
                }
            };

            var blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'memory-leak-test-report-' + new Date().getTime() + '.json';
            a.click();
            URL.revokeObjectURL(url);

            addTestResult('Export Report', 'SUCCESS', 'Memory test report exported');
        }

        function addTestResult(testName, status, message, details) {
            var result = {
                testName: testName,
                status: status,
                message: message,
                details: details,
                timestamp: new Date().toISOString()
            };

            memoryLeakDetector.testResults.push(result);

            var resultsDiv = document.getElementById('testResults');
            var resultDiv = document.createElement('div');
            resultDiv.className = 'test-result ' +
                (status === 'PASS' ? 'pass' :
                 status === 'FAIL' ? 'fail' :
                 status === 'WARNING' ? 'warning' : 'pending');

            var html = '<strong>' + testName + ':</strong> ' + status + ' - ' + message;

            if (details && details.recommendations && details.recommendations.length > 0) {
                html += '<br><strong>Recommendations:</strong><ul>';
                details.recommendations.forEach(function(rec) {
                    html += '<li>' + rec + '</li>';
                });
                html += '</ul>';
            }

            if (details && details.details) {
                html += '<br><strong>Details:</strong> ';
                if (details.details.heapGrowth !== undefined) {
                    html += 'Heap: ' + details.details.heapGrowth.toFixed(2) + ' MB, ';
                }
                if (details.details.observerGrowth !== undefined) {
                    html += 'Observers: +' + details.details.observerGrowth + ', ';
                }
                if (details.details.listenerGrowth !== undefined) {
                    html += 'Listeners: +' + details.details.listenerGrowth;
                }
            }

            resultDiv.innerHTML = html;
            resultsDiv.appendChild(resultDiv);
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            memoryLeakDetector.testResults = [];
            memoryLeakDetector.measurements = [];
        }

        // Initialize memory leak detection
        function initializeMemoryLeakDetection() {
            patchMutationObserver();
            patchEventListeners();
            recordMemoryMeasurement();

            addTestResult('Memory Leak Detection System', 'READY', 'Ready to detect memory leaks in form tracking operations');
        }

        // Start monitoring when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeMemoryLeakDetection);
        } else {
            initializeMemoryLeakDetection();
        }
    </script>
</body>
</html>